//
// Qt4xHb - Bindings libraries for Harbour/xHarbour and Qt Framework 4
//
// Copyright (c) 2025 Marcos Antonio Gambeta <marcosgambeta@outlook.com>
//

// DO NOT EDIT THIS FILE - the content was created using a source code generator

// clang-format off

#include <hbclass.ch>

#ifndef QT4XHB_NO_REQUESTS
REQUEST QSslCertificate
REQUEST QSslCipher
REQUEST QSslConfiguration
REQUEST QSslError
REQUEST QSslKey
REQUEST QVariant
#endif

CLASS QSslSocket INHERIT QTcpSocket

   METHOD new
   METHOD delete
   METHOD abort
   METHOD addCaCertificate
   METHOD addCaCertificates
   METHOD caCertificates
   METHOD ciphers
   METHOD connectToHostEncrypted
   METHOD encryptedBytesAvailable
   METHOD encryptedBytesToWrite
   METHOD flush
   METHOD ignoreSslErrors
   METHOD isEncrypted
   METHOD localCertificate
   METHOD mode
   METHOD peerCertificate
   METHOD peerCertificateChain
   METHOD peerVerifyDepth
   METHOD peerVerifyMode
   METHOD privateKey
   METHOD protocol
   METHOD sessionCipher
   METHOD setCaCertificates
   METHOD setCiphers
   METHOD setLocalCertificate
   METHOD setPeerVerifyDepth
   METHOD setPeerVerifyMode
   METHOD setPrivateKey
   METHOD setProtocol
   METHOD setReadBufferSize
   METHOD setSocketDescriptor
   METHOD setSocketOption
   METHOD setSslConfiguration
   METHOD socketOption
   METHOD sslConfiguration
   METHOD sslErrors
   METHOD waitForConnected
   METHOD waitForDisconnected
   METHOD waitForEncrypted
   METHOD atEnd
   METHOD bytesAvailable
   METHOD bytesToWrite
   METHOD canReadLine
   METHOD close
   METHOD waitForBytesWritten
   METHOD waitForReadyRead
   METHOD startClientEncryption
   METHOD startServerEncryption
   METHOD addDefaultCaCertificate
   METHOD addDefaultCaCertificates
   METHOD defaultCaCertificates
   METHOD defaultCiphers
   METHOD setDefaultCaCertificates
   METHOD setDefaultCiphers
   METHOD supportedCiphers
   METHOD supportsSsl
   METHOD systemCaCertificates

   METHOD onEncrypted
   METHOD onEncryptedBytesWritten
   METHOD onModeChanged
   METHOD onPeerVerifyError
   METHOD onSslErrors

   DESTRUCTOR destroyObject

END CLASS

PROCEDURE destroyObject() CLASS QSslSocket
   IF ::self_destruction
      ::delete()
   ENDIF
RETURN

// clang-format on

#pragma BEGINDUMP

#include <QtNetwork/QSslSocket>

#include "qt4xhb_common.hpp"
#include "qt4xhb_macros.hpp"
#include "qt4xhb_utils.hpp"
#include "qt4xhb_events.hpp"
#include "qt4xhb_signals.hpp"

#include <QtNetwork/QSslKey>
#include <QtNetwork/QSslCipher>
#include <QtNetwork/QSslConfiguration>

#define GET_PTR_FROM_SELF(p) QSslSocket *p = qobject_cast<QSslSocket *>(Qt4xHb::getQObjectPointerFromSelfItem())

// QSslSocket(QObject *parent = 0)
HB_FUNC_STATIC(QSSLSOCKET_NEW)
{
  if (ISBETWEEN(0, 1) && ISQOBJECTORNIL(1)) {
    QSslSocket *obj = new QSslSocket(OPQOBJECT(1, 0));
    Qt4xHb::returnNewObject(obj, false);
  } else {
    hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
  }
}

HB_FUNC_STATIC(QSSLSOCKET_DELETE)
{
  GET_PTR_FROM_SELF(obj);

  DELETE_QOBJECT(obj);

  RETURN_SELF();
}

// void abort()
HB_FUNC_STATIC(QSSLSOCKET_ABORT)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != NULL) {
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      obj->abort();
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    } else {
      hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
    }
#endif
  }

  RETURN_SELF();
}

// void addCaCertificate(const QSslCertificate &certificate)
HB_FUNC_STATIC(QSSLSOCKET_ADDCACERTIFICATE)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != NULL) {
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(1) && ISQSSLCERTIFICATE(1)) {
#endif
      obj->addCaCertificate(*PQSSLCERTIFICATE(1));
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    } else {
      hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
    }
#endif
  }

  RETURN_SELF();
}

HB_FUNC_STATIC(QSSLSOCKET_ADDCACERTIFICATES)
{
  if (ISBETWEEN(1, 3) && HB_ISCHAR(1) && ISNUMORNIL(2) && ISNUMORNIL(3)) {
    // bool addCaCertificates(const QString &path, QSsl::EncodingFormat format = QSsl::Pem, QRegExp::PatternSyntax
    // syntax = QRegExp::FixedString)
    GET_PTR_FROM_SELF(obj);

    if (obj != NULL) {
      RBOOL(obj->addCaCertificates(
          PQSTRING(1), HB_ISNIL(2) ? static_cast<QSsl::EncodingFormat>(QSsl::Pem) : PQSSL_ENCODINGFORMAT(2),
          HB_ISNIL(3) ? static_cast<QRegExp::PatternSyntax>(QRegExp::FixedString) : PQREGEXP_PATTERNSYNTAX(3)));
    }
  } else if (ISNUMPAR(1) && HB_ISARRAY(1)) {
    // void addCaCertificates(const QList<QSslCertificate> &certificates)
    GET_PTR_FROM_SELF(obj);

    if (obj != NULL) {
      QList<QSslCertificate> par1;
      PHB_ITEM aList1 = hb_param(1, HB_IT_ARRAY);
      int nLen1 = hb_arrayLen(aList1);
      for (int i1 = 0; i1 < nLen1; i1++) {
        par1 << *static_cast<QSslCertificate *>(
            hb_itemGetPtr(hb_objSendMsg(hb_arrayGetItemPtr(aList1, i1 + 1), "POINTER", 0)));
      }
      obj->addCaCertificates(par1);
    }

    RETURN_SELF();
  } else {
    hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
  }
}

// QList<QSslCertificate> caCertificates() const
HB_FUNC_STATIC(QSSLSOCKET_CACERTIFICATES)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != NULL) {
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      QList<QSslCertificate> list = obj->caCertificates();
      PHB_DYNS pDynSym = hb_dynsymFindName("QSSLCERTIFICATE");
      PHB_ITEM pArray = hb_itemArrayNew(0);
      if (pDynSym != NULL) {
        const int count = list.count();
        for (int i = 0; i < count; i++) {
          hb_vmPushDynSym(pDynSym);
          hb_vmPushNil();
          hb_vmDo(0);
          PHB_ITEM pObject = hb_itemNew(NULL);
          hb_itemCopy(pObject, hb_stackReturnItem());
          PHB_ITEM pItem = hb_itemPutPtr(NULL, new QSslCertificate(list[i]));
          hb_objSendMsg(pObject, "_POINTER", 1, pItem);
          hb_itemRelease(pItem);
          PHB_ITEM pDestroy = hb_itemPutL(NULL, true);
          hb_objSendMsg(pObject, "_SELF_DESTRUCTION", 1, pDestroy);
          hb_itemRelease(pDestroy);
          hb_arrayAddForward(pArray, pObject);
          hb_itemRelease(pObject);
        }
      } else {
        hb_errRT_BASE(EG_NOFUNC, 1001, NULL, "QSSLCERTIFICATE", HB_ERR_ARGS_BASEPARAMS);
      }
      hb_itemReturnRelease(pArray);
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    } else {
      hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
    }
#endif
  }
}

// QList<QSslCipher> ciphers() const
HB_FUNC_STATIC(QSSLSOCKET_CIPHERS)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != NULL) {
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      QList<QSslCipher> list = obj->ciphers();
      PHB_DYNS pDynSym = hb_dynsymFindName("QSSLCIPHER");
      PHB_ITEM pArray = hb_itemArrayNew(0);
      if (pDynSym != NULL) {
        const int count = list.count();
        for (int i = 0; i < count; i++) {
          hb_vmPushDynSym(pDynSym);
          hb_vmPushNil();
          hb_vmDo(0);
          PHB_ITEM pObject = hb_itemNew(NULL);
          hb_itemCopy(pObject, hb_stackReturnItem());
          PHB_ITEM pItem = hb_itemPutPtr(NULL, new QSslCipher(list[i]));
          hb_objSendMsg(pObject, "_POINTER", 1, pItem);
          hb_itemRelease(pItem);
          PHB_ITEM pDestroy = hb_itemPutL(NULL, true);
          hb_objSendMsg(pObject, "_SELF_DESTRUCTION", 1, pDestroy);
          hb_itemRelease(pDestroy);
          hb_arrayAddForward(pArray, pObject);
          hb_itemRelease(pObject);
        }
      } else {
        hb_errRT_BASE(EG_NOFUNC, 1001, NULL, "QSSLCIPHER", HB_ERR_ARGS_BASEPARAMS);
      }
      hb_itemReturnRelease(pArray);
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    } else {
      hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
    }
#endif
  }
}

HB_FUNC_STATIC(QSSLSOCKET_CONNECTTOHOSTENCRYPTED)
{
  if (ISBETWEEN(2, 3) && HB_ISCHAR(1) && HB_ISNUM(2) && ISNUMORNIL(3)) {
    // void connectToHostEncrypted(const QString &hostName, quint16 port, QIODevice::OpenMode mode =
    // QIODevice::ReadWrite)
    GET_PTR_FROM_SELF(obj);

    if (obj != NULL) {
      obj->connectToHostEncrypted(PQSTRING(1), PQUINT16(2),
                                  HB_ISNIL(3) ? static_cast<QIODevice::OpenMode>(QIODevice::ReadWrite)
                                              : PQIODEVICE_OPENMODE(3));
    }

    RETURN_SELF();
  } else if (ISBETWEEN(3, 4) && HB_ISCHAR(1) && HB_ISNUM(2) && HB_ISCHAR(3) && ISNUMORNIL(4)) {
    // void connectToHostEncrypted(const QString &hostName, quint16 port, const QString &sslPeerName,
    // QIODevice::OpenMode mode = QIODevice::ReadWrite)
    GET_PTR_FROM_SELF(obj);

    if (obj != NULL) {
      obj->connectToHostEncrypted(PQSTRING(1), PQUINT16(2), PQSTRING(3),
                                  HB_ISNIL(4) ? static_cast<QIODevice::OpenMode>(QIODevice::ReadWrite)
                                              : PQIODEVICE_OPENMODE(4));
    }

    RETURN_SELF();
  } else {
    hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
  }
}

// qint64 encryptedBytesAvailable() const
HB_FUNC_STATIC(QSSLSOCKET_ENCRYPTEDBYTESAVAILABLE)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != NULL) {
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      RQINT64(obj->encryptedBytesAvailable());
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    } else {
      hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
    }
#endif
  }
}

// qint64 encryptedBytesToWrite() const
HB_FUNC_STATIC(QSSLSOCKET_ENCRYPTEDBYTESTOWRITE)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != NULL) {
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      RQINT64(obj->encryptedBytesToWrite());
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    } else {
      hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
    }
#endif
  }
}

// bool flush()
HB_FUNC_STATIC(QSSLSOCKET_FLUSH)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != NULL) {
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      RBOOL(obj->flush());
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    } else {
      hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
    }
#endif
  }
}

HB_FUNC_STATIC(QSSLSOCKET_IGNORESSLERRORS)
{
  if (ISNUMPAR(1) && HB_ISARRAY(1)) {
    // void ignoreSslErrors(const QList<QSslError> &errors)
    GET_PTR_FROM_SELF(obj);

    if (obj != NULL) {
      QList<QSslError> par1;
      PHB_ITEM aList1 = hb_param(1, HB_IT_ARRAY);
      int nLen1 = hb_arrayLen(aList1);
      for (int i1 = 0; i1 < nLen1; i1++) {
        par1 << *static_cast<QSslError *>(
            hb_itemGetPtr(hb_objSendMsg(hb_arrayGetItemPtr(aList1, i1 + 1), "POINTER", 0)));
      }
      obj->ignoreSslErrors(par1);
    }

    RETURN_SELF();
  } else if (ISNUMPAR(0)) {
    // void ignoreSslErrors()
    GET_PTR_FROM_SELF(obj);

    if (obj != NULL) {
      obj->ignoreSslErrors();
    }

    RETURN_SELF();
  } else {
    hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
  }
}

// bool isEncrypted() const
HB_FUNC_STATIC(QSSLSOCKET_ISENCRYPTED)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != NULL) {
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      RBOOL(obj->isEncrypted());
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    } else {
      hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
    }
#endif
  }
}

// QSslCertificate localCertificate() const
HB_FUNC_STATIC(QSSLSOCKET_LOCALCERTIFICATE)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != NULL) {
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      RQSSLCERTIFICATE(obj->localCertificate());
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    } else {
      hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
    }
#endif
  }
}

// QSslSocket::SslMode mode() const
HB_FUNC_STATIC(QSSLSOCKET_MODE)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != NULL) {
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      RENUM(obj->mode());
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    } else {
      hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
    }
#endif
  }
}

// QSslCertificate peerCertificate() const
HB_FUNC_STATIC(QSSLSOCKET_PEERCERTIFICATE)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != NULL) {
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      RQSSLCERTIFICATE(obj->peerCertificate());
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    } else {
      hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
    }
#endif
  }
}

// QList<QSslCertificate> peerCertificateChain() const
HB_FUNC_STATIC(QSSLSOCKET_PEERCERTIFICATECHAIN)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != NULL) {
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      QList<QSslCertificate> list = obj->peerCertificateChain();
      PHB_DYNS pDynSym = hb_dynsymFindName("QSSLCERTIFICATE");
      PHB_ITEM pArray = hb_itemArrayNew(0);
      if (pDynSym != NULL) {
        const int count = list.count();
        for (int i = 0; i < count; i++) {
          hb_vmPushDynSym(pDynSym);
          hb_vmPushNil();
          hb_vmDo(0);
          PHB_ITEM pObject = hb_itemNew(NULL);
          hb_itemCopy(pObject, hb_stackReturnItem());
          PHB_ITEM pItem = hb_itemPutPtr(NULL, new QSslCertificate(list[i]));
          hb_objSendMsg(pObject, "_POINTER", 1, pItem);
          hb_itemRelease(pItem);
          PHB_ITEM pDestroy = hb_itemPutL(NULL, true);
          hb_objSendMsg(pObject, "_SELF_DESTRUCTION", 1, pDestroy);
          hb_itemRelease(pDestroy);
          hb_arrayAddForward(pArray, pObject);
          hb_itemRelease(pObject);
        }
      } else {
        hb_errRT_BASE(EG_NOFUNC, 1001, NULL, "QSSLCERTIFICATE", HB_ERR_ARGS_BASEPARAMS);
      }
      hb_itemReturnRelease(pArray);
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    } else {
      hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
    }
#endif
  }
}

// int peerVerifyDepth() const
HB_FUNC_STATIC(QSSLSOCKET_PEERVERIFYDEPTH)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != NULL) {
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      RINT(obj->peerVerifyDepth());
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    } else {
      hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
    }
#endif
  }
}

// QSslSocket::PeerVerifyMode peerVerifyMode() const
HB_FUNC_STATIC(QSSLSOCKET_PEERVERIFYMODE)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != NULL) {
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      RENUM(obj->peerVerifyMode());
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    } else {
      hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
    }
#endif
  }
}

// QSslKey privateKey() const
HB_FUNC_STATIC(QSSLSOCKET_PRIVATEKEY)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != NULL) {
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      RQSSLKEY(obj->privateKey());
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    } else {
      hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
    }
#endif
  }
}

// QSsl::SslProtocol protocol() const
HB_FUNC_STATIC(QSSLSOCKET_PROTOCOL)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != NULL) {
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      RENUM(obj->protocol());
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    } else {
      hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
    }
#endif
  }
}

// QSslCipher sessionCipher() const
HB_FUNC_STATIC(QSSLSOCKET_SESSIONCIPHER)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != NULL) {
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      RQSSLCIPHER(obj->sessionCipher());
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    } else {
      hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
    }
#endif
  }
}

// void setCaCertificates(const QList<QSslCertificate> &certificates)
HB_FUNC_STATIC(QSSLSOCKET_SETCACERTIFICATES)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != NULL) {
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(1) && HB_ISARRAY(1)) {
#endif
      QList<QSslCertificate> par1;
      PHB_ITEM aList1 = hb_param(1, HB_IT_ARRAY);
      int nLen1 = hb_arrayLen(aList1);
      for (int i1 = 0; i1 < nLen1; i1++) {
        par1 << *static_cast<QSslCertificate *>(
            hb_itemGetPtr(hb_objSendMsg(hb_arrayGetItemPtr(aList1, i1 + 1), "POINTER", 0)));
      }
      obj->setCaCertificates(par1);
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    } else {
      hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
    }
#endif
  }

  RETURN_SELF();
}

HB_FUNC_STATIC(QSSLSOCKET_SETCIPHERS)
{
  if (ISNUMPAR(1) && HB_ISARRAY(1)) {
    // void setCiphers(const QList<QSslCipher> &ciphers)
    GET_PTR_FROM_SELF(obj);

    if (obj != NULL) {
      QList<QSslCipher> par1;
      PHB_ITEM aList1 = hb_param(1, HB_IT_ARRAY);
      int nLen1 = hb_arrayLen(aList1);
      for (int i1 = 0; i1 < nLen1; i1++) {
        par1 << *static_cast<QSslCipher *>(
            hb_itemGetPtr(hb_objSendMsg(hb_arrayGetItemPtr(aList1, i1 + 1), "POINTER", 0)));
      }
      obj->setCiphers(par1);
    }

    RETURN_SELF();
  } else if (ISNUMPAR(1) && HB_ISCHAR(1)) {
    // void setCiphers(const QString &ciphers)
    GET_PTR_FROM_SELF(obj);

    if (obj != NULL) {
      obj->setCiphers(PQSTRING(1));
    }

    RETURN_SELF();
  } else {
    hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
  }
}

HB_FUNC_STATIC(QSSLSOCKET_SETLOCALCERTIFICATE)
{
  if (ISNUMPAR(1) && ISQSSLCERTIFICATE(1)) {
    // void setLocalCertificate(const QSslCertificate &certificate)
    GET_PTR_FROM_SELF(obj);

    if (obj != NULL) {
      obj->setLocalCertificate(*PQSSLCERTIFICATE(1));
    }

    RETURN_SELF();
  } else if (ISBETWEEN(1, 2) && HB_ISCHAR(1) && ISNUMORNIL(2)) {
    // void setLocalCertificate(const QString &path, QSsl::EncodingFormat format = QSsl::Pem)
    GET_PTR_FROM_SELF(obj);

    if (obj != NULL) {
      obj->setLocalCertificate(PQSTRING(1),
                               HB_ISNIL(2) ? static_cast<QSsl::EncodingFormat>(QSsl::Pem) : PQSSL_ENCODINGFORMAT(2));
    }

    RETURN_SELF();
  } else {
    hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
  }
}

// void setPeerVerifyDepth(int depth)
HB_FUNC_STATIC(QSSLSOCKET_SETPEERVERIFYDEPTH)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != NULL) {
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(1) && HB_ISNUM(1)) {
#endif
      obj->setPeerVerifyDepth(PINT(1));
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    } else {
      hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
    }
#endif
  }

  RETURN_SELF();
}

// void setPeerVerifyMode(QSslSocket::PeerVerifyMode mode)
HB_FUNC_STATIC(QSSLSOCKET_SETPEERVERIFYMODE)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != NULL) {
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(1) && HB_ISNUM(1)) {
#endif
      obj->setPeerVerifyMode(PQSSLSOCKET_PEERVERIFYMODE(1));
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    } else {
      hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
    }
#endif
  }

  RETURN_SELF();
}

HB_FUNC_STATIC(QSSLSOCKET_SETPRIVATEKEY)
{
  if (ISNUMPAR(1) && ISQSSLKEY(1)) {
    // void setPrivateKey(const QSslKey &key)
    GET_PTR_FROM_SELF(obj);

    if (obj != NULL) {
      obj->setPrivateKey(*PQSSLKEY(1));
    }

    RETURN_SELF();
  } else if (ISBETWEEN(1, 4) && HB_ISCHAR(1) && ISNUMORNIL(2) && ISNUMORNIL(3) && (ISQBYTEARRAY(4) || HB_ISNIL(4))) {
    // void setPrivateKey(const QString &fileName, QSsl::KeyAlgorithm algorithm = QSsl::Rsa, QSsl::EncodingFormat format
    // = QSsl::Pem, const QByteArray &passPhrase = QByteArray())
    GET_PTR_FROM_SELF(obj);

    if (obj != NULL) {
      obj->setPrivateKey(PQSTRING(1), HB_ISNIL(2) ? static_cast<QSsl::KeyAlgorithm>(QSsl::Rsa) : PQSSL_KEYALGORITHM(2),
                         HB_ISNIL(3) ? static_cast<QSsl::EncodingFormat>(QSsl::Pem) : PQSSL_ENCODINGFORMAT(3),
                         HB_ISNIL(4) ? QByteArray() : *static_cast<QByteArray *>(Qt4xHb::itemGetPtr(4)));
    }

    RETURN_SELF();
  } else {
    hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
  }
}

// void setProtocol(QSsl::SslProtocol protocol)
HB_FUNC_STATIC(QSSLSOCKET_SETPROTOCOL)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != NULL) {
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(1) && HB_ISNUM(1)) {
#endif
      obj->setProtocol(PQSSL_SSLPROTOCOL(1));
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    } else {
      hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
    }
#endif
  }

  RETURN_SELF();
}

// void setReadBufferSize(qint64 size)
HB_FUNC_STATIC(QSSLSOCKET_SETREADBUFFERSIZE)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != NULL) {
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(1) && HB_ISNUM(1)) {
#endif
      obj->setReadBufferSize(PQINT64(1));
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    } else {
      hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
    }
#endif
  }

  RETURN_SELF();
}

// bool setSocketDescriptor(int socketDescriptor, QAbstractSocket::SocketState state = QAbstractSocket::ConnectedState,
// QIODevice::OpenMode openMode = QIODevice::ReadWrite)
HB_FUNC_STATIC(QSSLSOCKET_SETSOCKETDESCRIPTOR)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != NULL) {
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    if (ISBETWEEN(1, 3) && HB_ISNUM(1) && ISNUMORNIL(2) && ISNUMORNIL(3)) {
#endif
      RBOOL(obj->setSocketDescriptor(
          PINT(1),
          HB_ISNIL(2) ? static_cast<QAbstractSocket::SocketState>(QAbstractSocket::ConnectedState)
                      : PQABSTRACTSOCKET_SOCKETSTATE(2),
          HB_ISNIL(3) ? static_cast<QIODevice::OpenMode>(QIODevice::ReadWrite) : PQIODEVICE_OPENMODE(3)));
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    } else {
      hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
    }
#endif
  }
}

// void setSocketOption(QAbstractSocket::SocketOption option, const QVariant &value)
HB_FUNC_STATIC(QSSLSOCKET_SETSOCKETOPTION)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != NULL) {
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(2) && HB_ISNUM(1) && ISQVARIANT(2)) {
#endif
      obj->setSocketOption(PQABSTRACTSOCKET_SOCKETOPTION(1), *PQVARIANT(2));
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    } else {
      hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
    }
#endif
  }

  RETURN_SELF();
}

// void setSslConfiguration(const QSslConfiguration &configuration)
HB_FUNC_STATIC(QSSLSOCKET_SETSSLCONFIGURATION)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != NULL) {
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(1) && ISQSSLCONFIGURATION(1)) {
#endif
      obj->setSslConfiguration(*PQSSLCONFIGURATION(1));
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    } else {
      hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
    }
#endif
  }

  RETURN_SELF();
}

// QVariant socketOption(QAbstractSocket::SocketOption option)
HB_FUNC_STATIC(QSSLSOCKET_SOCKETOPTION)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != NULL) {
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(1) && HB_ISNUM(1)) {
#endif
      RQVARIANT(obj->socketOption(PQABSTRACTSOCKET_SOCKETOPTION(1)));
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    } else {
      hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
    }
#endif
  }
}

// QSslConfiguration sslConfiguration() const
HB_FUNC_STATIC(QSSLSOCKET_SSLCONFIGURATION)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != NULL) {
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      RQSSLCONFIGURATION(obj->sslConfiguration());
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    } else {
      hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
    }
#endif
  }
}

// QList<QSslError> sslErrors() const
HB_FUNC_STATIC(QSSLSOCKET_SSLERRORS)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != NULL) {
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      QList<QSslError> list = obj->sslErrors();
      PHB_DYNS pDynSym = hb_dynsymFindName("QSSLERROR");
      PHB_ITEM pArray = hb_itemArrayNew(0);
      if (pDynSym != NULL) {
        const int count = list.count();
        for (int i = 0; i < count; i++) {
          hb_vmPushDynSym(pDynSym);
          hb_vmPushNil();
          hb_vmDo(0);
          PHB_ITEM pObject = hb_itemNew(NULL);
          hb_itemCopy(pObject, hb_stackReturnItem());
          PHB_ITEM pItem = hb_itemPutPtr(NULL, new QSslError(list[i]));
          hb_objSendMsg(pObject, "_POINTER", 1, pItem);
          hb_itemRelease(pItem);
          PHB_ITEM pDestroy = hb_itemPutL(NULL, true);
          hb_objSendMsg(pObject, "_SELF_DESTRUCTION", 1, pDestroy);
          hb_itemRelease(pDestroy);
          hb_arrayAddForward(pArray, pObject);
          hb_itemRelease(pObject);
        }
      } else {
        hb_errRT_BASE(EG_NOFUNC, 1001, NULL, "QSSLERROR", HB_ERR_ARGS_BASEPARAMS);
      }
      hb_itemReturnRelease(pArray);
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    } else {
      hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
    }
#endif
  }
}

// bool waitForConnected(int msecs = 30000)
HB_FUNC_STATIC(QSSLSOCKET_WAITFORCONNECTED)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != NULL) {
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    if (ISBETWEEN(0, 1) && ISNUMORNIL(1)) {
#endif
      RBOOL(obj->waitForConnected(OPINT(1, 30000)));
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    } else {
      hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
    }
#endif
  }
}

// bool waitForDisconnected(int msecs = 30000)
HB_FUNC_STATIC(QSSLSOCKET_WAITFORDISCONNECTED)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != NULL) {
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    if (ISBETWEEN(0, 1) && ISNUMORNIL(1)) {
#endif
      RBOOL(obj->waitForDisconnected(OPINT(1, 30000)));
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    } else {
      hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
    }
#endif
  }
}

// bool waitForEncrypted(int msecs = 30000)
HB_FUNC_STATIC(QSSLSOCKET_WAITFORENCRYPTED)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != NULL) {
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    if (ISBETWEEN(0, 1) && ISNUMORNIL(1)) {
#endif
      RBOOL(obj->waitForEncrypted(OPINT(1, 30000)));
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    } else {
      hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
    }
#endif
  }
}

// virtual bool atEnd() const
HB_FUNC_STATIC(QSSLSOCKET_ATEND)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != NULL) {
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      RBOOL(obj->atEnd());
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    } else {
      hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
    }
#endif
  }
}

// virtual qint64 bytesAvailable() const
HB_FUNC_STATIC(QSSLSOCKET_BYTESAVAILABLE)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != NULL) {
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      RQINT64(obj->bytesAvailable());
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    } else {
      hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
    }
#endif
  }
}

// virtual qint64 bytesToWrite() const
HB_FUNC_STATIC(QSSLSOCKET_BYTESTOWRITE)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != NULL) {
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      RQINT64(obj->bytesToWrite());
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    } else {
      hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
    }
#endif
  }
}

// virtual bool canReadLine() const
HB_FUNC_STATIC(QSSLSOCKET_CANREADLINE)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != NULL) {
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      RBOOL(obj->canReadLine());
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    } else {
      hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
    }
#endif
  }
}

// virtual void close()
HB_FUNC_STATIC(QSSLSOCKET_CLOSE)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != NULL) {
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      obj->close();
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    } else {
      hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
    }
#endif
  }

  RETURN_SELF();
}

// virtual bool waitForBytesWritten(int msecs = 30000)
HB_FUNC_STATIC(QSSLSOCKET_WAITFORBYTESWRITTEN)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != NULL) {
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    if (ISBETWEEN(0, 1) && ISNUMORNIL(1)) {
#endif
      RBOOL(obj->waitForBytesWritten(OPINT(1, 30000)));
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    } else {
      hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
    }
#endif
  }
}

// virtual bool waitForReadyRead(int msecs = 30000)
HB_FUNC_STATIC(QSSLSOCKET_WAITFORREADYREAD)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != NULL) {
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    if (ISBETWEEN(0, 1) && ISNUMORNIL(1)) {
#endif
      RBOOL(obj->waitForReadyRead(OPINT(1, 30000)));
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    } else {
      hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
    }
#endif
  }
}

// void startClientEncryption()
HB_FUNC_STATIC(QSSLSOCKET_STARTCLIENTENCRYPTION)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != NULL) {
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      obj->startClientEncryption();
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    } else {
      hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
    }
#endif
  }

  RETURN_SELF();
}

// void startServerEncryption()
HB_FUNC_STATIC(QSSLSOCKET_STARTSERVERENCRYPTION)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != NULL) {
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      obj->startServerEncryption();
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    } else {
      hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
    }
#endif
  }

  RETURN_SELF();
}

// static void addDefaultCaCertificate(const QSslCertificate &certificate)
HB_FUNC_STATIC(QSSLSOCKET_ADDDEFAULTCACERTIFICATE)
{
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
  if (ISNUMPAR(1) && ISQSSLCERTIFICATE(1)) {
#endif
    QSslSocket::addDefaultCaCertificate(*PQSSLCERTIFICATE(1));
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
  } else {
    hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
  }
#endif

  RETURN_SELF();
}

HB_FUNC_STATIC(QSSLSOCKET_ADDDEFAULTCACERTIFICATES)
{
  if (ISBETWEEN(1, 3) && HB_ISCHAR(1) && ISNUMORNIL(2) && ISNUMORNIL(3)) {
    // static bool addDefaultCaCertificates(const QString &path, QSsl::EncodingFormat encoding = QSsl::Pem,
    // QRegExp::PatternSyntax syntax = QRegExp::FixedString)

    RBOOL(QSslSocket::addDefaultCaCertificates(
        PQSTRING(1), HB_ISNIL(2) ? static_cast<QSsl::EncodingFormat>(QSsl::Pem) : PQSSL_ENCODINGFORMAT(2),
        HB_ISNIL(3) ? static_cast<QRegExp::PatternSyntax>(QRegExp::FixedString) : PQREGEXP_PATTERNSYNTAX(3)));
  } else if (ISNUMPAR(1) && HB_ISARRAY(1)) {
    // void addDefaultCaCertificates(const QList<QSslCertificate> &certificates)
    GET_PTR_FROM_SELF(obj);

    if (obj != NULL) {
      QList<QSslCertificate> par1;
      PHB_ITEM aList1 = hb_param(1, HB_IT_ARRAY);
      int nLen1 = hb_arrayLen(aList1);
      for (int i1 = 0; i1 < nLen1; i1++) {
        par1 << *static_cast<QSslCertificate *>(
            hb_itemGetPtr(hb_objSendMsg(hb_arrayGetItemPtr(aList1, i1 + 1), "POINTER", 0)));
      }
      obj->addDefaultCaCertificates(par1);
    }

    RETURN_SELF();
  } else {
    hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
  }
}

// QList<QSslCertificate> defaultCaCertificates()
HB_FUNC_STATIC(QSSLSOCKET_DEFAULTCACERTIFICATES)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != NULL) {
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      QList<QSslCertificate> list = obj->defaultCaCertificates();
      PHB_DYNS pDynSym = hb_dynsymFindName("QSSLCERTIFICATE");
      PHB_ITEM pArray = hb_itemArrayNew(0);
      if (pDynSym != NULL) {
        const int count = list.count();
        for (int i = 0; i < count; i++) {
          hb_vmPushDynSym(pDynSym);
          hb_vmPushNil();
          hb_vmDo(0);
          PHB_ITEM pObject = hb_itemNew(NULL);
          hb_itemCopy(pObject, hb_stackReturnItem());
          PHB_ITEM pItem = hb_itemPutPtr(NULL, new QSslCertificate(list[i]));
          hb_objSendMsg(pObject, "_POINTER", 1, pItem);
          hb_itemRelease(pItem);
          PHB_ITEM pDestroy = hb_itemPutL(NULL, true);
          hb_objSendMsg(pObject, "_SELF_DESTRUCTION", 1, pDestroy);
          hb_itemRelease(pDestroy);
          hb_arrayAddForward(pArray, pObject);
          hb_itemRelease(pObject);
        }
      } else {
        hb_errRT_BASE(EG_NOFUNC, 1001, NULL, "QSSLCERTIFICATE", HB_ERR_ARGS_BASEPARAMS);
      }
      hb_itemReturnRelease(pArray);
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    } else {
      hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
    }
#endif
  }
}

// QList<QSslCipher> defaultCiphers()
HB_FUNC_STATIC(QSSLSOCKET_DEFAULTCIPHERS)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != NULL) {
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      QList<QSslCipher> list = obj->defaultCiphers();
      PHB_DYNS pDynSym = hb_dynsymFindName("QSSLCIPHER");
      PHB_ITEM pArray = hb_itemArrayNew(0);
      if (pDynSym != NULL) {
        const int count = list.count();
        for (int i = 0; i < count; i++) {
          hb_vmPushDynSym(pDynSym);
          hb_vmPushNil();
          hb_vmDo(0);
          PHB_ITEM pObject = hb_itemNew(NULL);
          hb_itemCopy(pObject, hb_stackReturnItem());
          PHB_ITEM pItem = hb_itemPutPtr(NULL, new QSslCipher(list[i]));
          hb_objSendMsg(pObject, "_POINTER", 1, pItem);
          hb_itemRelease(pItem);
          PHB_ITEM pDestroy = hb_itemPutL(NULL, true);
          hb_objSendMsg(pObject, "_SELF_DESTRUCTION", 1, pDestroy);
          hb_itemRelease(pDestroy);
          hb_arrayAddForward(pArray, pObject);
          hb_itemRelease(pObject);
        }
      } else {
        hb_errRT_BASE(EG_NOFUNC, 1001, NULL, "QSSLCIPHER", HB_ERR_ARGS_BASEPARAMS);
      }
      hb_itemReturnRelease(pArray);
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    } else {
      hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
    }
#endif
  }
}

// void setDefaultCaCertificates(const QList<QSslCertificate> &certificates)
HB_FUNC_STATIC(QSSLSOCKET_SETDEFAULTCACERTIFICATES)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != NULL) {
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(1) && HB_ISARRAY(1)) {
#endif
      QList<QSslCertificate> par1;
      PHB_ITEM aList1 = hb_param(1, HB_IT_ARRAY);
      int nLen1 = hb_arrayLen(aList1);
      for (int i1 = 0; i1 < nLen1; i1++) {
        par1 << *static_cast<QSslCertificate *>(
            hb_itemGetPtr(hb_objSendMsg(hb_arrayGetItemPtr(aList1, i1 + 1), "POINTER", 0)));
      }
      obj->setDefaultCaCertificates(par1);
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    } else {
      hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
    }
#endif
  }

  RETURN_SELF();
}

// void setDefaultCiphers(const QList<QSslCipher> &ciphers)
HB_FUNC_STATIC(QSSLSOCKET_SETDEFAULTCIPHERS)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != NULL) {
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(1) && HB_ISARRAY(1)) {
#endif
      QList<QSslCipher> par1;
      PHB_ITEM aList1 = hb_param(1, HB_IT_ARRAY);
      int nLen1 = hb_arrayLen(aList1);
      for (int i1 = 0; i1 < nLen1; i1++) {
        par1 << *static_cast<QSslCipher *>(
            hb_itemGetPtr(hb_objSendMsg(hb_arrayGetItemPtr(aList1, i1 + 1), "POINTER", 0)));
      }
      obj->setDefaultCiphers(par1);
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    } else {
      hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
    }
#endif
  }

  RETURN_SELF();
}

// QList<QSslCipher> supportedCiphers()
HB_FUNC_STATIC(QSSLSOCKET_SUPPORTEDCIPHERS)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != NULL) {
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      QList<QSslCipher> list = obj->supportedCiphers();
      PHB_DYNS pDynSym = hb_dynsymFindName("QSSLCIPHER");
      PHB_ITEM pArray = hb_itemArrayNew(0);
      if (pDynSym != NULL) {
        const int count = list.count();
        for (int i = 0; i < count; i++) {
          hb_vmPushDynSym(pDynSym);
          hb_vmPushNil();
          hb_vmDo(0);
          PHB_ITEM pObject = hb_itemNew(NULL);
          hb_itemCopy(pObject, hb_stackReturnItem());
          PHB_ITEM pItem = hb_itemPutPtr(NULL, new QSslCipher(list[i]));
          hb_objSendMsg(pObject, "_POINTER", 1, pItem);
          hb_itemRelease(pItem);
          PHB_ITEM pDestroy = hb_itemPutL(NULL, true);
          hb_objSendMsg(pObject, "_SELF_DESTRUCTION", 1, pDestroy);
          hb_itemRelease(pDestroy);
          hb_arrayAddForward(pArray, pObject);
          hb_itemRelease(pObject);
        }
      } else {
        hb_errRT_BASE(EG_NOFUNC, 1001, NULL, "QSSLCIPHER", HB_ERR_ARGS_BASEPARAMS);
      }
      hb_itemReturnRelease(pArray);
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    } else {
      hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
    }
#endif
  }
}

// static bool supportsSsl()
HB_FUNC_STATIC(QSSLSOCKET_SUPPORTSSSL)
{
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
  if (ISNUMPAR(0)) {
#endif
    RBOOL(QSslSocket::supportsSsl());
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
  } else {
    hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
  }
#endif
}

// QList<QSslCertificate> systemCaCertificates()
HB_FUNC_STATIC(QSSLSOCKET_SYSTEMCACERTIFICATES)
{
  GET_PTR_FROM_SELF(obj);

  if (obj != NULL) {
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    if (ISNUMPAR(0)) {
#endif
      QList<QSslCertificate> list = obj->systemCaCertificates();
      PHB_DYNS pDynSym = hb_dynsymFindName("QSSLCERTIFICATE");
      PHB_ITEM pArray = hb_itemArrayNew(0);
      if (pDynSym != NULL) {
        const int count = list.count();
        for (int i = 0; i < count; i++) {
          hb_vmPushDynSym(pDynSym);
          hb_vmPushNil();
          hb_vmDo(0);
          PHB_ITEM pObject = hb_itemNew(NULL);
          hb_itemCopy(pObject, hb_stackReturnItem());
          PHB_ITEM pItem = hb_itemPutPtr(NULL, new QSslCertificate(list[i]));
          hb_objSendMsg(pObject, "_POINTER", 1, pItem);
          hb_itemRelease(pItem);
          PHB_ITEM pDestroy = hb_itemPutL(NULL, true);
          hb_objSendMsg(pObject, "_SELF_DESTRUCTION", 1, pDestroy);
          hb_itemRelease(pDestroy);
          hb_arrayAddForward(pArray, pObject);
          hb_itemRelease(pObject);
        }
      } else {
        hb_errRT_BASE(EG_NOFUNC, 1001, NULL, "QSSLCERTIFICATE", HB_ERR_ARGS_BASEPARAMS);
      }
      hb_itemReturnRelease(pArray);
#ifndef QT4XHB_DONT_CHECK_PARAMETERS
    } else {
      hb_errRT_BASE(EG_ARG, 3012, NULL, HB_ERR_FUNCNAME, HB_ERR_ARGS_BASEPARAMS);
    }
#endif
  }
}

void QSslSocketSlots_connect_signal(const QString &signal, const QString &slot);

#define CONNECT_SIGNAL(signal) QSslSocketSlots_connect_signal(signal, signal)

HB_FUNC_STATIC(QSSLSOCKET_ONENCRYPTED)
{
  CONNECT_SIGNAL("encrypted()");
}

HB_FUNC_STATIC(QSSLSOCKET_ONENCRYPTEDBYTESWRITTEN)
{
  CONNECT_SIGNAL("encryptedBytesWritten(qint64)");
}

HB_FUNC_STATIC(QSSLSOCKET_ONMODECHANGED)
{
  CONNECT_SIGNAL("modeChanged(QSslSocket::SslMode)");
}

HB_FUNC_STATIC(QSSLSOCKET_ONPEERVERIFYERROR)
{
  CONNECT_SIGNAL("peerVerifyError(QSslError)");
}

HB_FUNC_STATIC(QSSLSOCKET_ONSSLERRORS)
{
  CONNECT_SIGNAL("sslErrors(QList<QSslError>)");
}

#pragma ENDDUMP
